# Продвинутый Марио

|   Cобытие   | Название | Категория | Сложность |
| :---------: | :------: | :-------: | :-------: |
| VKACTF 2023 |  Загадки Лихолесья  |  Crypto  |  Легкий  |

## Описание

>Автор: Inssurg3nt
>
>Марио выяснил, что принцесса Пич хранит в своем облачном хранилище какие-то фотографии... Марио уже продвинулся в IT и решил что сражаться с Боузером и бежать к башне куда сложнее, чем посмотреть фотографии в интернете. Однако принцесса, как единственная девушка грибного королевства, сочла такое предложение за наглость и не дала Марио пароль от хранилища.

# Решение

1. Флаг шифруется алгоритмом AES_CTR, значит нам необходимо восстановить ключ шифрования 
    get_encrypted_flag()
2. Ключом шифроавания флага является захэшированный параметр x закрытого ключа шифрования по схеме Эль-Гамаля
3. Заметим, что в задании реализована схема обмена клчами, используемая в облачном хранилище MEGA. От этого факта нам нужно лишь понять, что различные типы ключей, которые тут используются не имеют большого значения, а нам интересен лишь share_key, так как в нем хранится необходимый нам параметр.4. Используя функцию send_challenge, мы можем отправить зашифрованный по схеме Эль-Гамаля SID_enc, и получить в ответ расшифрованный SID. Анализируя пары значений SID-SID_enc мы и будем постепенно получать закрытый параметр x.
4. Проанализируем функцию расшифрования 
    M = b * (a^x)^(-1) mod p
Смотрим на формулу: если b это квадратичный вычет (а мы сами на вход будем подавать это значение), то будет ли итоговый результат вычетом или нет теперь зависит от a^x. И если итоговый результат это вычет, то это значит, что x оканчивается на 0, если не вычет, то на 1
5. Соответтвенно, подавая на вход определенные параметры (к примеру b = 4, a = 2) и определяя Символ Лежандра, мы можем вычислить последний бит параметра x. Заметим так же, что ошибка в функции расшифрования, обрезающая параметр x при вычислении формулы, позволяет восстановить последующие биты аналогичным образом.
    m = b * (inverse(pow(a, x[:len_x], p), p)) % p
6. Для изменения длины, нам необходимо проанализировать схему построения share_key: он шифруется алгоритмом AES_CTR, а значит последняя операция - xor, и для одного и того ж ключа, зная пару значений plaintext-ciphertext, мы можем восстановить ключ, с которым ксорятся известные нам байты (назовем его xor_key). Так, зная длину исходного значения x - 1024 бита, мы можем восстановить xor_key, и использовать его для подмены используемой длины x
7.  Расшифровываем ФЛАГ с помощью восстановленного закрытого ключа.


[Решение](solve.py)
### Флаг

```
vka{El_Mario_-_megalomaniac_vuln_edition}

```