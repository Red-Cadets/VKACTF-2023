from sage.all import *
from sage.modules.free_module_integer import IntegerLattice
from z3 import *
import os
from itertools import starmap
from operator import mul
from random import randint
from Crypto.Util.number import long_to_bytes

def Babai_closest_vector(M, G, target):
    small = target
    for _ in range(1):
        for i in reversed(range(M.nrows())):
            c = ((small * G[i]) / (G[i] * G[i])).round()
            small -= M[i] * c
    return target - small

def CVP_attack(A_values, b_values,q,m,n):
    A = matrix(ZZ, m + n, m)
    for i in range(m):
        A[i, i] = q
    for x in range(m):
        for y in range(n):
            A[m + y, x] = A_values[x][y]
    lattice = IntegerLattice(A, lll_reduce=True)
    print("LLL done")
    gram = lattice.reduced_basis.gram_schmidt()[0]
    target = vector(ZZ, b_values)
    res = Babai_closest_vector(lattice.reduced_basis, gram, target)
    print("Closest Vector: {}".format(res))

    R = IntegerModRing(q)
    M = Matrix(R, A_values)
    Secret = M.solve_right(res)
    
    print("Secret: {}".format(Secret))
    E = []
    for row, b in zip(A_values, b_values):
        effect = sum(starmap(mul, zip(map(int, Secret), row))) % q
        assert(abs(b - effect) % 16 == 0)
        E.append(abs(b - effect) // 16)
    print("ok")
    return Secret, E

def decrypt(C,S,n,q):
    pt = ""
    for ct in C:
        a,b = ct
        V = VectorSpace(GF(q), n)
        a = V(a)
        b = GF(q)(b)
        pt += str(hex(int(b - a * S) % 16)[2:])
    pt = bytes.fromhex(pt).decode()
    return pt

def encrypt(message,A,B,q,n):
    m = len(A)
    V = VectorSpace(GF(q), n)
    mes = message.encode().hex()
    C = []
    for bit in mes:
        k = [randint(0,m-1) for i in range(10)]
        ct = [0, int(bit,16)]
        for i in k:
            ct[0] += V(A[i])
            ct[1] += GF(q)(B[i])
        C.append(ct)
    return C

def get_new_transaction(message, A, B,q,n):
    point = "999"
    start,end = message.split(":")[0],message.split(":")[2]
    new_message = start + ":" + point + ":" + end
    enc_new_mesage = encrypt(new_message,A,B,q,n)
    f = open(f"new_ciphertext.txt" , "w")
    f.write(pack_(enc_new_mesage))
    f.close()
    print("Файл с новой транзакцией создан!")

def func(X):
    res = (((X[0] or X[1]) and ((not X[1]) or (not X[2])))) or (not (X[2] or (not X[0])))
    return int(res)

def check_correlation_attack():
    check_attack = False
    m_chet = [0] * 3
    for i in range(8):
        x_ = "{:03b}".format(i)
        x_ = [int(k) for k in x_]
        res = func(x_)
        print(x_ , " -> ", res)
        for j in range(len(x_)):
            if res == x_[j]:
                m_chet[j] += 1
    print(m_chet)
    for j in range(len(m_chet)):
        if m_chet[j] >= 6: 
            check_attack = True
    return check_attack

def pack_(M):
    res = ""
    for data in M:
        A,b = data
        res += "".join(hex(len(long_to_bytes(int(i)).hex()))[2:].rjust(2,"0") + long_to_bytes(int(i)).hex()  for i in list(A)+[b])
        res += "\n"
    return res

def unpack_( C: str):
    C = C.strip().split("\n")
    M = []
    for data in C:
        A = []
        while len(data) > 0:
            l = data[:2]
            l = int(l , 16)
            a = data[2 : 2+l]
            a = int(a , 16)
            A.append(a)
            data = data[ 2 + l :]
        M.append([A[:-1] , A[-1]])
    return M

def correlation_attack(E):
    output_generator = []
    for i in range(len(E)):
        data = list(bin(E[i])[2:].rjust(8,"0"))
        data = [int(j) for j in data]
        output_generator.extend(data)
    s = Solver()
    KEY = [BitVec(f"k_{i}", 1) for i in range(64)]
    F_e = Func_errors(KEY)
    for b in output_generator:
        s.add(F_e.errors() == b)
    assert s.check() == sat
    key = int(''.join(str(s.model()[k]) for k in KEY),2)
    print(bin(key))
    key = bin(key)[2:].rjust(64,"0")
    key = list(map(int,list(key)))
    F_e_new = Func_errors(key)
    key_bot = ""
    k = int(input("Введите k (количество шагов назад): "))
    for i in range(3):
        state = F_e_new.LFSR[i].inv_clock(k)
        state = [str(j) for j in state]
        key_bot += "".join(state)

    print(key_bot)
    key_bot = int(key_bot , 2)
    return long_to_bytes(key_bot).hex()


class LFSR():
    def __init__(self, key,taps):
        self.state = key
        self.taps = taps
    
    def sum(self, m):
        res = 0
        for i in m:
            res ^= i
        return res

    def clock(self ):
        x = self.state[0]
        self.state = self.state[1:] + [self.sum([self.state[i] for i in self.taps])]
        return x
    
    def inv_clock(self , k):
        state_0 = self.state
        for i in range(k):
            x = state_0[-1]
            state_0 = [self.sum([state_0[j-1] for j in self.taps[1:]] + [x])] + state_0[:-1]
        return state_0
    
class Func_errors():
    def __init__(self, key):
        self.LFSR = [
            LFSR(key[:22],[0,4, 5, 7, 8, 9, 10, 11, 21]),
            LFSR(key[22:22 + 18],[0, 9, 11, 17]),
            LFSR(key[22 + 18:] ,[0,2, 4, 6, 8, 9, 12, 13, 14, 15, 23])
        ]
    
    def func(self,X):
        res = (((X[0] | X[1]) & ((~ X[1]) | (~ X[2])))) | (~ (X[2] | (~ X[0])))
        return res

    def errors(self):
        X = [i.clock() for i in self.LFSR]
        return self.func(X)
    
path_dir = input("Введите директорию: ")#Директория, в которой лежат все файлы с открытыми ключами
os.chdir(path_dir)
t = os.scandir("./")
Pk = ""
Ct = ""
for i in t:
    if "pubkey" in i.name:
        data = open(i.name , "r").read()
        Pk += data
    if "ciphertext" in i.name:
        data = open(i.name , "r").read()
        Ct += data
Pk = unpack_(Pk)
Ct = unpack_(Ct)

b = [i[1] for i in Pk ]
A = [i[0] for i in Pk ]

n = len(A[0])
m = len(A)
q = 852006456193809007988777

S , E = CVP_attack(A,b,q,m,n)

print("E = ", E)

transaction_decrypt = decrypt(Ct,S , n,q)

print("Message = ",transaction_decrypt)

get_new_transaction(transaction_decrypt , A , b,q,n)#Подделываем транзакцию на прибавление 999 коинов

print("Проверка на возможность проведения корреляционной атаки...")

check = check_correlation_attack()
print(check)
if check == True:
    print("Восстанавливаем секрет")
    bot_key = correlation_attack(E)
    print("Ключ от бота: ",bot_key)
